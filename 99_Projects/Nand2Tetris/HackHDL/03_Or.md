## Specification

### Truth Table

| A | B | A OR B |
|---|---|--------|
| 0 | 0 |   0    |
| 0 | 1 |   1    |
| 1 | 0 |   1    |
| 1 | 1 |   1    |

>[!example]-
> ```mermaid
> graph LR;
>     %% パターン0: A=0, B=0
>     A0["A"] -->|<span style="color:#aa0000">0</span>| Or0["OR"]:::gate;
>     B0["B"] -->|<span style="color:#aa0000">0</span>| Or0;
>     Or0 -->|<span style="color:#aa0000">0</span>| OUT0["Output"];
>     
>     %% パターン1: A=0, B=1
>     A1["A"] -->|<span style="color:#aa0000">0</span>| Or1["OR"]:::gate;
>     B1["B"] -->|<span style="color:#00aa00">1</span>| Or1;
>     Or1 -->|<span style="color:#00aa00">1</span>| OUT1["Output"];
>     
>     %% パターン2: A=1, B=0
>     A2["A"] -->|<span style="color:#00aa00">1</span>| Or2["OR"]:::gate;
>     B2["B"] -->|<span style="color:#aa0000">0</span>| Or2;
>     Or2 -->|<span style="color:#00aa00">1</span>| OUT2["Output"];
>     
>     %% パターン3: A=1, B=1
>     A3["A"] -->|<span style="color:#00aa00">1</span>| Or3["OR"]:::gate;
>     B3["B"] -->|<span style="color:#00aa00">1</span>| Or3;
>     Or3 -->|<span style="color:#00aa00">1</span>| OUT3["Output"];
> 
>     classDef gate fill:#d0d0d0,stroke:#000,stroke-width:2px;
>     style A0 fill:#ff9999
>     style B0 fill:#ff9999
>     style A1 fill:#ff9999
>     style B1 fill:#99ff99
>     style A2 fill:#99ff99
>     style B2 fill:#ff9999
>     style A3 fill:#99ff99
>     style B3 fill:#99ff99
>     style OUT0 fill:#ff9999
>     style OUT1 fill:#99ff99
>     style OUT2 fill:#99ff99
>     style OUT3 fill:#99ff99
> ```

---

## Implementation

### Logical Expression (Step-by-Step)

>[!tip]
>$$
>A \lor B = (\lnot A \land B) \lor (A \land \lnot B) \lor (A \land B)
>$$
>
>**Step 1:** 各真出力のミンタームを抽出  
> - A=0, B=1: $\lnot A \land B$  
> - A=1, B=0: $A \land \lnot B$  
> - A=1, B=1: $A \land B$
>
>**Step 2:** 共通項の抽出  
> $$= (\lnot A \land B) \lor \bigl[A \land (\lnot B \lor B)\bigr]$$
>
>**Step 3:** 恒等式 $\lnot B \lor B = 1$ を適用  
> $$= (\lnot A \land B) \lor A$$
>
>**Step 4:** 分配法則により整理  
> $$= A \lor B$$

### Standard Implementation (And/Or/Not Version)

```vhdl
CHIP Or {
    IN a, b;
    OUT out;
PARTS:
    // 標準のORゲート実装（内蔵ORを利用）
    Or(a=a, b=b, out=out);
}
````

```mermaid
graph LR;
    A["A"] --> OrGate["OR"]:::gate;
    B["B"] --> OrGate;
    OrGate --> OUT["out"];
    
    classDef gate fill:#d0d0d0,stroke:#000,stroke-width:2px;
```

> [!example]-
> 
> ```mermaid
> graph LR;
>     %% パターン0: A=0, B=0
>     A0["A"] -->|<span style="color:#aa0000">0</span>| Or0["OR"]:::gate;
>     B0["B"] -->|<span style="color:#aa0000">0</span>| Or0;
>     Or0 -->|<span style="color:#aa0000">0</span>| OUT0["Output"];
>     
>     %% パターン1: A=0, B=1
>     A1["A"] -->|<span style="color:#aa0000">0</span>| Or1["OR"]:::gate;
>     B1["B"] -->|<span style="color:#00aa00">1</span>| Or1;
>     Or1 -->|<span style="color:#00aa00">1</span>| OUT1["Output"];
>     
>     %% パターン2: A=1, B=0
>     A2["A"] -->|<span style="color:#00aa00">1</span>| Or2["OR"]:::gate;
>     B2["B"] -->|<span style="color:#aa0000">0</span>| Or2;
>     Or2 -->|<span style="color:#00aa00">1</span>| OUT2["Output"];
>     
>     %% パターン3: A=1, B=1
>     A3["A"] -->|<span style="color:#00aa00">1</span>| Or3["OR"]:::gate;
>     B3["B"] -->|<span style="color:#00aa00">1</span>| Or3;
>     Or3 -->|<span style="color:#00aa00">1</span>| OUT3["Output"];
> 
>     classDef gate fill:#d0d0d0,stroke:#000,stroke-width:2px;
>     style A0 fill:#ff9999
>     style B0 fill:#ff9999
>     style A1 fill:#ff9999
>     style B1 fill:#99ff99
>     style A2 fill:#99ff99
>     style B2 fill:#ff9999
>     style A3 fill:#99ff99
>     style B3 fill:#99ff99
>     style OUT0 fill:#ff9999
>     style OUT1 fill:#99ff99
>     style OUT2 fill:#99ff99
>     style OUT3 fill:#99ff99
> ```

---

### Optimized Implementation (NAND Only Version)

#### HackHDL Code

```vhdl
CHIP Or {
    IN a, b;
    OUT out;
PARTS:
    // NANDを用いたORゲートの実装
    Nand(a=a, b=a, out=notA);
    Nand(a=b, b=b, out=notB);
    Nand(a=notA, b=notB, out=out);
}
```

#### Implementation Graph

```mermaid
graph LR;
    A["A"] --> NotA["Nand(A,A)"]:::gate;
    B["B"] --> NotB["Nand(B,B)"]:::gate;
    NotA --> OrOpt["Nand(NotA,NotB)"]:::gate;
    NotB --> OrOpt;
    OrOpt --> OUT["out"];
    
    classDef gate fill:#d0d0d0,stroke:#000,stroke-width:2px;
```

> [!example]-
> 
> ```mermaid
> graph LR;
>     %% パターン0: A=0, B=0
>     A0["A"] -->|<span style="color:#aa0000">0</span>| NotA0["Nand(A,A)"]:::gate;
>     B0["B"] -->|<span style="color:#aa0000">0</span>| NotB0["Nand(B,B)"]:::gate;
>     NotA0 -->|<span style="color:#00aa00">1</span>| NandOpt0["Nand(NotA,NotB)"]:::gate;
>     NotB0 -->|<span style="color:#00aa00">1</span>| NandOpt0;
>     NandOpt0 -->|<span style="color:#aa0000">0</span>| OUT0["Output"];
>     
>     %% パターン1: A=0, B=1
>     A1["A"] -->|<span style="color:#aa0000">0</span>| NotA1["Nand(A,A)"]:::gate;
>     B1["B"] -->|<span style="color:#00aa00">1</span>| NotB1["Nand(B,B)"]:::gate;
>     NotA1 -->|<span style="color:#aa0000">0</span>| NandOpt1["Nand(NotA,NotB)"]:::gate;
>     NotB1 -->|<span style="color:#aa0000">0</span>| NandOpt1;
>     NandOpt1 -->|<span style="color:#00aa00">1</span>| OUT1["Output"];
>     
>     %% パターン2: A=1, B=0
>     A2["A"] -->|<span style="color:#00aa00">1</span>| NotA2["Nand(A,A)"]:::gate;
>     B2["B"] -->|<span style="color:#aa0000">0</span>| NotB2["Nand(B,B)"]:::gate;
>     NotA2 -->|<span style="color:#aa0000">0</span>| NandOpt2["Nand(NotA,NotB)"]:::gate;
>     NotB2 -->|<span style="color:#00aa00">1</span>| NandOpt2;
>     NandOpt2 -->|<span style="color:#00aa00">1</span>| OUT2["Output"];
>     
>     %% パターン3: A=1, B=1
>     A3["A"] -->|<span style="color:#00aa00">1</span>| NotA3["Nand(A,A)"]:::gate;
>     B3["B"] -->|<span style="color:#00aa00">1</span>| NotB3["Nand(B,B)"]:::gate;
>     NotA3 -->|<span style="color:#00aa00">1</span>| NandOpt3["Nand(NotA,NotB)"]:::gate;
>     NotB3 -->|<span style="color:#00aa00">1</span>| NandOpt3;
>     NandOpt3 -->|<span style="color:#00aa00">1</span>| OUT3["Output"];
> 
>     classDef gate fill:#d0d0d0,stroke:#000,stroke-width:2px;
>     style A0 fill:#ff9999
>     style B0 fill:#ff9999
>     style A1 fill:#ff9999
>     style B1 fill:#99ff99
>     style A2 fill:#99ff99
>     style B2 fill:#ff9999
>     style A3 fill:#99ff99
>     style B3 fill:#99ff99
>     style OUT0 fill:#ff9999
>     style OUT1 fill:#99ff99
>     style OUT2 fill:#99ff99
>     style OUT3 fill:#99ff99
> ```

---

> [!prove]- Orゲートの最適化手順  
> 以下、ORゲートをNANDのみで実装する最適化プロセスを **ステップバイステップで図解** します。各段階の論理式と回路構造の変化をMermaid図で表現します。
> 
> ---
> 
> ### 最適化前の論理式（基本形）
> 
> A∨BA \lor B
> 
> ```mermaid
> graph LR;
>     A["A"] --> Or["OR"];
>     B["B"] --> Or;
>     Or --> OUT["Output"];
> 
>     classDef gate fill:#ddd,stroke:#000;
> ```
> 
> ---
> 
> ### 最適化ステップ 1: De Morganの法則を適用
> 
> ORゲートを以下のように変換します:
> 
> A∨B=¬(¬A∧¬B)A \lor B = \lnot(\lnot A \land \lnot B)
> 
> ```mermaid
> graph LR;
>     A["A"] --> NotA["Not A"];
>     B["B"] --> NotB["Not B"];
>     NotA --> And0["AND"]:::gate;
>     NotB --> And0;
>     And0 --> NotOut["Not"];
>     NotOut --> OUT["Output"];
> 
>     classDef gate fill:#ddd,stroke:#000;
> ```
> 
> ---
> 
> ### 最適化ステップ 2: NOTをNANDで置換
> 
> NOTゲートをNANDゲートで実装します:
> 
> ¬A=A↑A,¬B=B↑B\lnot A = A \uparrow A,\quad \lnot B = B \uparrow B
> 
> ```mermaid
> graph LR;
>     A["A"] --> NandA["Nand(A,A)"]:::gate;
>     B["B"] --> NandB["Nand(B,B)"]:::gate;
>     NandA --> And0["AND"]:::gate;
>     NandB --> And0;
>     And0 --> NotOut["Not"]:::gate;
>     NotOut --> OUT["Output"];
> 
>     classDef gate fill:#ddd,stroke:#000;
> ```
> 
> ---
> 
> ### 最適化ステップ 3: ANDをNANDで置換し、最終形へ
> 
> ANDゲートとNOTゲートの組み合わせをNANDゲートのみで実装します:
> 
> A∨B=(A↑A)↑(B↑B)A \lor B = (A \uparrow A) \uparrow (B \uparrow B)
> 
> ```mermaid
> graph LR;
>     A["A"] --> NandA["Nand(A,A)"]:::gate;
>     B["B"] --> NandB["Nand(B,B)"]:::gate;
>     NandA --> NandOut["Nand(NandA,NandB)"]:::gate;
>     NandB --> NandOut;
>     NandOut --> OUT["Output"];
> 
>     classDef gate fill:#ddd,stroke:#000;
> ```
> 
> ---
> 
> ### 最終結論
> 
> **2つのNANDゲートによる実装** が最小構成であり、この最適化により:
> 
> - 論理ゲート数が削減
> - 信号伝播遅延が短縮
> - ハードウェアコストが低減
> 
> この構造は、数学的にもハードウェア的にも **完全なOR動作** を保証します。