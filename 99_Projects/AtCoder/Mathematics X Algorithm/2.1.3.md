## コード例 1

```lisp
(let ((n (read)))
  (loop with ans = 0
        repeat n
        for a = (read)
        do (incf ans a)
        finally (format t "~A~%" ans)))
```

- **`(let ((n (read))) ...)`**
    - 標準入力から `read` を用いて整数を読み込み、その値をローカル変数 `n` に束縛します。
- **`(loop with ans = 0 repeat n for a = (read) do (incf ans a) finally (format t "~A~%" ans))`**
    - `loop` マクロを使った反復処理です。
    - **`with ans = 0`**
        - ローカル変数 `ans` を初期値 `0` で定義します。これは合計値を保持するための変数です。
    - **`repeat n`**
        - 変数 `n` の回数だけループを繰り返します。
    - **`for a = (read)`**
        - 各反復で、標準入力から1つの値を `read` で読み込み、変数 `a` に束縛します。
    - **`do (incf ans a)`**
        - `incf` は変数の値をインクリメントする関数です。ここでは `ans` に `a` の値を加算します。
    - **`finally (format t "~A~%" ans)`**
        - ループの最後に、`ans` の値をフォーマット文字列 `"~A~%"` を用いて標準出力に出力します。
        - `~A` は値を読みやすく表示し、`~%` は改行を意味します。

---

## コード例 2

```lisp
(setq sum 0)
(dotimes (i (read))
  (setq sum (+ sum (read)))
)
(print sum)
```

- **`(setq sum 0)`**
    
    - グローバル変数 `sum` を初期値 `0` で設定します。
- **`(dotimes (i (read)) ...)`**
    
    - `dotimes` は指定された回数だけ反復処理を行います。
    - `(read)` により、標準入力から整数を読み込み、その数だけループします。
    - ループ変数 `i` は使われていませんが、反復回数の管理に利用されます。
- **`(setq sum (+ sum (read)))`**
    
    - 各反復で、標準入力から新たな整数を `read` で読み込み、現在の `sum` にその値を加算して `sum` に再代入します。
- **`(print sum)`**
    
    - `print` 関数を用いて `sum` の値を出力します。
    - `print` は Lisp オブジェクトを標準的な形式で出力し、出力後に改行も自動で挿入されます。

---

## コード例 3

```lisp
(defparameter N (read))
(defparameter i 0)
(defparameter sum 0)

(loop
  (if (= i N) (return))
  (setq sum (+ sum (read)))
  (setq i (+ i 1))
)

(princ sum)
```

- **`(defparameter N (read))`**
    
    - グローバル変数 `N` を定義し、標準入力から読み込んだ整数で初期化します。
    - `defparameter` は再初期化可能なグローバル変数を定義するためのキーワードです。
- **`(defparameter i 0)` および `(defparameter sum 0)`**
    
    - カウンタ用の変数 `i` と合計を保持する変数 `sum` をグローバルに定義し、初期値 `0` を設定します。
- **`(loop ... )`**
    
    - 無限ループを開始します。
    - **`(if (= i N) (return))`**
        - ループの先頭で、カウンタ `i` と `N` を比較し、等しければ `return` でループから抜けます。
    - **`(setq sum (+ sum (read)))`**
        - 標準入力から整数を読み込み、現在の `sum` に加算します。
    - **`(setq i (+ i 1))`**
        - カウンタ `i` を1増加させます。
    - このループは、`i` が `N` に達するまで続きます。
- **`(princ sum)`**
    
    - `princ` は、オブジェクトを人間に読みやすい形式で出力します。
    - ここでは最終的な合計 `sum` を出力します。`princ` は自動で改行を入れないため、必要に応じて明示的に改行を加えることも可能です。

---

## コード例 4

```lisp
(let ((n (read))
      (s 0))
  (dotimes (i n)
    (incf s (read)))
  (format t "~d" s))
```

- **`(let ((n (read)) (s 0)) ...)`**
    
    - `let` を使用してローカル変数 `n` と `s` を定義しています。
    - `n` は標準入力から `read` で読み込まれた整数で、反復回数を表します。
    - `s` は合計値を保持する変数で、初期値は `0` です。
- **`(dotimes (i n) (incf s (read)))`**
    
    - `dotimes` で変数 `n` の回数だけ反復処理を行います。
    - ループ内では、`read` を使って標準入力から整数を読み込み、`incf` により変数 `s` にその値を加算します。
- **`(format t "~d" s)`**
    
    - `format` 関数で、`s` の値を整数形式（`~d` は10進数出力）で標準出力に表示します。
    - この場合、改行は含まれていないため、必要なら `"~d~%"` とすることで改行も挿入可能です。

---

これらのコードはすべて、標準入力から整数の個数（またはループ回数）を読み込み、その後に続く整数を順に読み取って合計を計算し、出力するという基本的なアルゴリズムを実装しています。各例は同じ問題に対して異なる方法（`loop` マクロ、`dotimes`、`defparameter` を使った無限ループなど）でアプローチしており、Common Lisp における入力、反復、出力の書き方のバリエーションを示しています。