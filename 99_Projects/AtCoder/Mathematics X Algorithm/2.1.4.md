```lisp
(let ((product 1))
  (loop with n = 3
        repeat n
        for a = (read)
        do (setf product (* product a))
        finally (format t "~A~%" product)))
```

### コードの各部分の説明

- **`(let ((product 1)) ... )`**  
  - `let` フォームを使ってローカル変数 `product` を定義しています。  
  - ここでは積の初期値として乗法の単位元である `1` を設定しています。  
  - この `product` 変数は、ループ内で各入力値と掛け合わせるために使います。

- **`(loop with n = 3 ... )`**  
  - `loop` マクロを使用して反復処理を行います。  
  - `with n = 3` により、ローカル変数 `n` に 3 を設定します。  
  - これは、3 回の反復（3 つの整数を処理する）を意味します。

- **`repeat n`**  
  - `repeat n` は、`n` の回数（ここでは 3 回）ループを繰り返すことを指定します。

- **`for a = (read)`**  
  - 各反復ごとに、標準入力から 1 つの値を `read` 関数で読み込み、その値を変数 `a` に束縛します。  
  - これにより、ループの各回で入力された整数が `a` に格納されます。

- **`do (setf product (* product a))`**  
  - 各反復中に、現在の `product` と読み込んだ整数 `a` を掛け合わせ、その結果を `product` に再代入します。  
  - `setf` を使うことで、`product` の値を更新します。

- **`finally (format t "~A~%" product)`**  
  - ループの反復が終了した後、`finally` 節内の処理が実行されます。  
  - `format` 関数を使い、計算された積 `product` を出力します。  
  - フォーマット文字列 `"~A~%"` は、  
    - `~A` が引数を「読みやすい形式」で出力し、  
    - `~%` が改行を出力することを意味します。

---

### 全体の流れ

1. **初期化**: `product` に 1 を代入して初期化します。
2. **ループ開始**: 変数 `n` に 3 をセットし、3 回の反復処理を行います。
3. **各反復処理**:  
   - 各回、標準入力から整数を読み取り、変数 `a` に束縛します。  
   - 現在の `product` と `a` を掛け合わせ、その結果を `product` に再代入します。
4. **出力**: 3 回の反復が終わった後、最終的な `product` の値（つまり 3 つの整数の積）を出力します。

このように、`loop` マクロを用いることで、反復処理の回数指定、入力の読み込み、計算、出力までを一つのブロックで記述できるため、コードがコンパクトになっています。